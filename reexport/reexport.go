package reexport

import (
	"fmt"
	"go/ast"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
)

type Reexport struct {
	pkg   *ast.Package
	path  string
	lines []string
}

func New(pkg *ast.Package, path string) *Reexport {
	return &Reexport{
		pkg:   pkg,
		path:  path,
		lines: make([]string, 0, 128),
	}
}

func (r *Reexport) Generate() (out string, err error) {
	if len(r.lines) != 0 {
		err = errors.New("reused Reexport instance")
		return
	}
	r.lines = append(r.lines, "// This file is generated by goreexport")
	r.lines = append(r.lines, "// It's not recommended to modify it")
	r.lines = append(r.lines, fmt.Sprintf("package %s", r.pkg.Name))
	r.lines = append(r.lines, "")
	r.lines = append(r.lines, fmt.Sprintf("import %q", r.path))

	files := make([]string, 0, len(r.pkg.Files))
	for name := range r.pkg.Files {
		files = append(files, name)
	}

	for _, name := range files {
		r.lines = append(r.lines, "")
		err = r.appendFile(name, r.pkg.Files[name])
		if err != nil {
			err = errors.WithMessagef(err, "package %s", r.pkg.Name)
			return
		}
	}

	for i, line := range r.lines {
		line = strings.Trim(line, "\n")
		line = strings.TrimRight(line, " \t\n")
		r.lines[i] = line
	}
	r.lines = append(r.lines, "")

	out = strings.Join(r.lines, "\n")

	return
}

func (r *Reexport) appendFile(name string, file *ast.File) (err error) {
	_, fileName := filepath.Split(name)
	r.lines = append(r.lines, fmt.Sprintf("// %s", fileName), "")
	for i := range file.Decls {
		err = nil
		switch decl := file.Decls[i].(type) {
		case *ast.FuncDecl:
			if decl.Recv == nil {
				err = r.appendFunc(decl)
			}
		case *ast.GenDecl:
			for i := range decl.Specs {
				switch spec := decl.Specs[i].(type) {
				case *ast.ImportSpec:
					continue
				case *ast.TypeSpec:
					err = r.appendType(spec)
				case *ast.ValueSpec:
					err = r.appendValue(spec)
				default:
					return errors.Errorf("%s: unexpected spec type %T", fileName)
				}
			}
		default:
			return errors.Errorf("%s: unexpected decl type %T in %s", fileName)
		}
		if err != nil {
			return errors.WithMessage(err, r.pkg.Name)
		}
	}
	return nil
}

func (r *Reexport) appendType(spec *ast.TypeSpec) (err error) {
	if spec.Name.IsExported() {
		r.lines = append(r.lines, fmt.Sprintf("type %s = %s.%s", spec.Name.Name, r.pkg.Name, spec.Name.Name))
	}
	return nil
}

func (r *Reexport) appendValue(spec *ast.ValueSpec) (err error) {
	for _, name := range spec.Names {
		if name.IsExported() {
			kind := ""
			switch name.Obj.Kind {
			case ast.Con:
				kind = "const"
			case ast.Var:
				kind = "var"
			default:
				return errors.Errorf("appendValue: unexpected object kind %s for %s.%s",
					name.Obj.Kind.String(), r.pkg.Name, name.Name)
			}

			r.lines = append(r.lines, fmt.Sprintf("%s %s = %s.%s", kind, name.Name, r.pkg.Name, name.Name))
		}
	}
	return nil
}

func (r *Reexport) appendFunc(decl *ast.FuncDecl) (err error) {
	if decl.Recv != nil {
		return errors.Errorf("appendFunc: unexpected func with receiver %s", decl.Name.Name)
	}
	if decl.Name.IsExported() {
		r.lines = append(r.lines, fmt.Sprintf("var %s = %s.%s", decl.Name.Name, r.pkg.Name, decl.Name.Name))
	}
	return nil
}
